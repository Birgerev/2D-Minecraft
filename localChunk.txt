using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using LibNoise;

public class Chunk : MonoBehaviour
{
    public static Dictionary<int, Chunk> chunks = new Dictionary<int, Chunk>();

    public static int Width = 16, Height = 255;
    public static int RenderDistance = 2;
    public static int SpawnChunkDistance = 0;
    public static int SeaLevel = 62;
    public static int TickRate = 10;

    public GameObject blockPrefab;

    public int ChunkPosition = 0;
    public bool isSpawnChunk = false;
    public bool isLoaded = false;

    public Chunk rightChunk;
    public Chunk leftChunk;

    private void Start()
    {
        if (chunks.ContainsKey(ChunkPosition))
        {
            Debug.LogWarning("A duplicate of Chunk ["+ChunkPosition+"] has been destroyed.");
            Destroy(gameObject);
            return;
        }

        chunks.Add(ChunkPosition, this);

        gameObject.name = "Chunk [" + ChunkPosition + "]";
        transform.position = new Vector3(ChunkPosition * Width, 0, 0);

        StartCoroutine(GenerateChunk());
        StartCoroutine(Tick());
    }

    private void OnDestroy()
    {
        if(isLoaded)
            chunks.Remove(ChunkPosition);
    }

    private void Update()
    {
        isSpawnChunk = (ChunkPosition <= SpawnChunkDistance || ChunkPosition >= -SpawnChunkDistance);
    }

    public static Chunk GetChunk(int cPos)
    {
        Chunk chunk = null;
        
        if(chunks.ContainsKey(cPos))
            chunk = chunks[cPos];
        if(chunk == null)
        {
            if(cPos != 0)
                chunk = LoadChunk(cPos);
        }

        return chunk;
    }
    
    public Vector2Int worldToLocalPosition(Vector2Int worldPos)
    {
        Vector2Int locPos = worldPos - Vector2Int.CeilToInt((Vector2)transform.position);

        locPos.x = Mathf.Abs(locPos.x);
        locPos.x = locPos.x % (Width);

        return locPos;
    }

    public static Chunk GetChunkFromWorldPosition(int worldPos)
    {
        Chunk chunk = null;
        if (worldPos >= 0)
        {
            chunk = GetChunk(Mathf.FloorToInt(worldPos / (Width - 1)));
        }
        else
        {
            chunk = GetChunk(Mathf.CeilToInt(worldPos / Width) - 1);
            //print("world pos: " + worldPos + " chunk pos: " + (Mathf.CeilToInt(worldPos / Width)-1));
        }

        return chunk;
    }

    public static Chunk LoadChunk(int cPos)
    {
        Debug.Log("loading chunk "+cPos);
        GameObject newChunk = Instantiate(WorldManager.instance.chunkPrefab);

        newChunk.GetComponent<Chunk>().ChunkPosition = cPos;

        return newChunk.GetComponent<Chunk>();
    }

    IEnumerator Tick()
    {
        while (true)
        {
            yield return new WaitForSeconds(1 / TickRate);

            Vector2 playerPosition = Player.localInstance.transform.position;
            int chunkXPosition = ChunkPosition * (int)Width;
            float distanceFromPlayer = Mathf.Abs((ChunkPosition * Width) - playerPosition.x);

            //print(distanceFromPlayer + " " + RenderDistance * Width + "" );

            //Tick Blocks
            if (isLoaded)
            {
                //Update neighbor chunks
                if (distanceFromPlayer < RenderDistance * Width)
                {
                    if (rightChunk == null)
                    {
                        rightChunk = GetChunk(ChunkPosition + 1);
                    }
                    if (leftChunk == null)
                    {
                        leftChunk = GetChunk(ChunkPosition - 1);
                    }
                }


                Block[] blocks = transform.GetComponentsInChildren<Block>();
                float timePerBlock = (1 / TickRate) / blocks.Length;

                foreach (Block block in blocks)
                {
                    block.Tick();
                }
            }
        }
    }

    IEnumerator GenerateChunk()
    {
        noise = new LibNoise.Generator.Perlin(1f, 0f, 1f, 10, WorldManager.instance.world.seed, QualityMode.High);

        for (int x = 0; x <= Width; x++)
        {
            for (int y = 0; y <= Height; y++)
            {
                loadTheoreticalBlock(new Vector2Int(x, y));
            }
        }
        isLoaded = true;
        yield return new WaitForSeconds(1);
    }

    public static void setBlock(Vector2Int worldPos, Material mat)
    {
        Chunk chunk = GetChunkFromWorldPosition((int)worldPos.x);
        Vector2Int locPos = chunk.worldToLocalPosition(worldPos);

        chunk.setLocalBlock(locPos, mat);
    }

    public Block setLocalBlock(Vector2Int locPos, Material mat)
    {
        if (locPos.x < 0 || locPos.x > Width || locPos.y < 0 || locPos.y > Height)
        {
            Debug.LogWarning("Tried setting local block outside of chunk (" + locPos.x + ", " + locPos.y + ") inside Chunk [" + ChunkPosition + "]");
            return null;
        }

        //remove old block
        if (getLocalBlock(locPos) != null)
            Destroy(getLocalBlock(locPos).gameObject);
        
        //Place new block
        GameObject block = null;

        block = Instantiate(blockPrefab);
        System.Type type = System.Type.GetType(mat.ToString());

        //Attach it to the object
        block.AddComponent(type);

        block.transform.parent = transform;
        block.transform.localPosition = (Vector2)locPos;

        return block.GetComponent<Block>();
    }

    public static Block getBlock(Vector2Int worldPos)
    {
        Chunk chunk = GetChunkFromWorldPosition((int)worldPos.x);
        Block block = chunk.getLocalBlock(chunk.worldToLocalPosition(worldPos));

        return block;
    }

    public Block getLocalBlock(Vector2Int locPos)
    {
        if (locPos.x < 0 || locPos.x >= Width || locPos.y < 0 || locPos.y > Height)
        {
            Debug.LogWarning("Tried getting local block outside of chunk ("+locPos.x+", "+locPos.y+") inside Chunk ["+ChunkPosition+"]");
            return null;
        }
        Transform block = transform.Find("block ["+(locPos.x + (ChunkPosition * Width))+","+locPos.y+"]");

        if (block == null)
            return null;

        return block.GetComponent<Block>();
    }

    public Block loadTheoreticalBlock(Vector2Int locPos)
    {
        Block block = null;
        Material mat = Material.Air;


        if (mat == Material.Air)
            mat = getTheoreticalTerrainBlock(locPos);
        if (mat == Material.Air)
            return null;

        block = setLocalBlock(locPos, mat);

        return block;
    }
    
    LibNoise.Generator.Perlin noise;
    public Material getTheoreticalTerrainBlock(Vector2Int locPos)
    {
        Vector2Int worldPos = locPos;
        worldPos.x += (ChunkPosition * Width);

        System.Random r = 
new System.Random(WorldManager.instance.world.seed + 
(int)((float)worldPos.x / (float)worldPos.y * 1000));
        Material mat = Material.Air;


                    //-Terrain Generation-//
        double noiseValue = 
            noise.GetValue((float)worldPos.x / 20, (float)worldPos.y / 20, 1) + 4.0f;
        double density = 1;

        if(locPos.y > SeaLevel)
        {
            float heightWheight = 0.1f;
            density = noiseValue - (heightWheight * ((float)locPos.y - (SeaLevel-50)))+1.5;
        }

        if (density > 0.1f)
            mat = Material.Grass;
        if (density > 0.5f)
        {
            mat = Material.Stone;
        }


                    //-Bedrock Generation-//
        if (locPos.y <= 4)
        {
            //Fill layer 0 and then progressively less chance of bedrock further up
            if (locPos.y == 0)
                mat = Material.Bedrock;
            else if (r.Next(0, (int)locPos.y+2) <= 1)
                mat = Material.Bedrock;
        }

        return mat;
    }
}